中位数小技巧：
为了不分类讨论奇偶特性，此处使用了中位左和中位右的小技巧：
例如：0、1、2共3个，中位左和中位右都为1
例如：0、1、2、3共4个，中位左和中位右分别为1、2
无论哪种情况，真正的中位数都是中位左和中位右的平均值
中位左_id = (len-1) / 2
中位右_id = len / 2

方法1：n+m
其实该方法并不满足题目要求，是n+m时间复杂度的算法
该方法的思路比较简单，就是将需要的数据合并为一个数组，然后给出相应的位置
结果
	24 ms	7.8 MB

方法2：logn
假设数组A长度为n，数组B长度为n
寻找中位数就是寻找一种分割，将A、B都分割为两部分，使得左边等于右边;这种分割可以很极限，例如将A分为{0 ~ n-1, NULL}
为了不去讨论奇偶，如果是奇数，就让右边的个数比左边大1个，那么切割要满足
  A->{0 ~ i-1, i ~ n-1}
       i个      n-i个
  B->{0 ~ j-1, j ~ m-1}
       j个      n-j个
可以等价于如下约束
	1、i + j + (m + n) % 2 == n + m - i - j; #i和j的关联关系
    上式等价于j = (n+m)/2 - i;
	2、0<=i<=n; 0<=j<=m; #i和j的存在条件
	3、B[j-1] <= A[i]; A[i-1] <= B[j] #平分约束
根据上述分析，可以在A中使用二分探讨i的位置，然后根据约束1的计算得到j，看其是否满足约束2和3
其中约束2不满足说明，i选择的不合
	1）j > m，说明i太小了，才不得不靠j向右挪动来保持平衡
	2）j < 0, 同理说明i太大了
约束3不满足说明找到的i并非均分条件，而不满足又可以分为如下几种情况
	1）B[j-1] > A[i]，此时说明i过小
	2) A[i-1] > B[j]，此时说明i过大 
根据上述两种情况，从而挪动每次二分的结果。
当找到i之后，根据总个数的奇偶就可以推出中位数
结果
	4 ms	7.6 MB

方法3：log(min(n,m))
该方法是对方法2的优化
方法2是在数组a中进行二分，而可以看出，数组a长度不一定是最小的。
所以只要在长度最小的数组中进行二分时间复杂度即可进一步得到优化
结果
	4 ms	7.6 MB