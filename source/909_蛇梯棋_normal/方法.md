# 思路

使用bfs即可，该题目为了加速可以把已经二次进入的节点进行优化



# 结果

执行用时：16 ms, 在所有 C 提交中击败了87.27%的用户

内存消耗：5.8 MB, 在所有 C 提交中击败了100.00%的用户



# 犯错

1、在做跳转的时候忘记了应该先做跳转判断，而不是先看该节点是否已使用。因为存在一种场景是：
    该节点由其他节点跳转过来，但是本次是走过来的，因此虽然不能作为目标，但是可以作为跳板，错误代码如下

for (int step = 1; step <= 6; step++) {
      int dest = pos + step;
      if (g_map[dest].used == 1) continue; /* 已经到过了，裁减掉  */
      if (dest == target) return times + 1; / 到达目的地，结束 */

​      if (g_map[dest].dest >= 0) dest = g_map[dest].dest;

​      if (g_map[dest].used == 1) continue; /* 已经到过了，裁减掉 */

​      if (dest == target) return times + 1; /* 到达目的地，结束 */

​      pushQueue(dest, times + 1);

}

2、原始的思路在做裁剪使用，使用used标记，使用方法为从这个点走出去时置一。这就导致栈空间实际要远大于map的大小，从而导致内存越界。后面的解决方法为，在进入该节点时就置一。



# 技巧

1、为了减少循环队列操作的带来的时间消耗，此处使用的是普通队列。为了保证普通队列的长度合理，因此，做了合理的裁剪，从而保证最多每个节点仅进入一次，因此queue的长度也可以计算出来出来

2、使用了一个一维数组来承载二维数组的信息，后续二维数组就不再使用，进一步加快bfs的速度



# 想法

其实该题目比真的dijkstra要简单的多，因为dijkstra要涉及路径不等权的的情况，这意味着后入队列的路径有可能更短。

本题目正是基于这种想法，才做了合理性的裁剪：每个节点仅允许入队一次